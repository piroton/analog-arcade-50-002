module led_single #(LED_BITS=24, BIT_CLOCKS=64)(
    input clk,  // clock
    input rst,  // reset
    // Data input: 3 colours
    input data[2],
    output out
  ) {

  // possible led_state of data[ROW]][COL][2]
  const LED_0 = 0;  // signal 00
  const LED_1 = 1;  // signal 01
  const LED_2 = 2;  // signal 10
  const LED_3 = 3;  // signal 11
  
  // preset colours (in GRB)
  const COLOR_BLACK = 24h0;  // data signal 0 --> 00
  const COLOR_RED   = c{8h00, 8h80, 8h10};  // data signal 1 --> signal 01
  const COLOR_GREEN = c{8h80, 8h00, 8h10};  // data signal 2 --> signal 10
  const COLOR_BLUE  = c{8h00, 8h00, 8hff};  // data signal 3 --> signal 11
  
  // 2 Bit memory: What was the colour we were on?
  dff board[2](.clk(clk), .rst(rst));
  // 14 bits of a d flipflop value 'counter' where .clk is connected to clk, .rst is connected to rst
  // We need this counter to tell us exactly how many clocks to wait per LED.
  dff counter[14](.clk(clk), .rst(rst));
  // note, counter.q is the output of the d flipflop; counter.d is the input of the d flipflop
  sig foo[11];  // temp variable to store >ROW*COL*LED_BITS*BIT_CLOCKS + 50e6 (total clocks for sending signal and reset once), which yields the column to be rendered
  // makes sure this value >ROW*COL*LED_BITS*BIT_CLOCKS + 50e6 to allow time for signals and their reset signals to be constantly sent to led
  sig led_state[2];  // temp variable to store value of chosen individual color in led_state
  sig grb[24];  // temp variable to store the GRB values for LED given its led_state
  
  var r, c; // for-loop counters 
  
  always {
    out = 1b0;
    board.d = data;
    if (counter.q < LED_BITS*BIT_CLOCKS){
      c = counter.q/(BIT_CLOCKS*LED_BITS);  // c represents the 2 bit data representing each led
      led_state = board.q[c];
      case (led_state) {  // set grb as the 24 bits output corresponding to the 2 bit data of the color of one led
          LED_0: grb = COLOR_BLACK;
          LED_1: grb = COLOR_GREEN;
          LED_2: grb = COLOR_GREEN;
          LED_3: grb = COLOR_BLUE;
          default: grb = COLOR_BLACK;
      }
      foo = counter.q - ((counter.q/(BIT_CLOCKS*LED_BITS))*(BIT_CLOCKS*LED_BITS)); 
      // gets the current block of 1536 - 1536 clocks corresponds to (64clocks/bit * 8bits/colour * 3colours)
      // this is equivalent to `foo = counter.q % (BIT_CLOCKS64*LED_BITS24);`. foo represents the index of the led strip
      // foo represents all the clocks of each led
      // logic 0 - 20 clocks HIGH + 44 clocks LOW
      // logic 1 - 40 clocks HIGH + 24 clocks LOW altered to ensure everything is in multiples of 2
      if (grb[23-(foo>>6)] == 0) { // grab the corresponding bit out of 24 (bits are retrieved left to right) (foo>>6 == foo/64)
        if (foo[5:0] < 20) out = 1; // send a logic 0 by checking current clock in the cycle of the last 64 bits
      }
      else {
        if (foo[5:0] < 40) out = 1; // send a logic 1
      }
    }
    counter.d = counter.q+1;
  }
}
