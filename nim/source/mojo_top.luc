module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    input button,
    input io_reset,
    input io_startgame,
    // NEEDS EDITING FOR EXTERNAL I/O
    input io_button[2][5],  // I/O buttons
    output io_sel[4],       // Digit select on IO Shield
    output io_seg[8],       // 7-segment LEDs on IO Shield
    // NEEDS EDITING IN CONSTRAINTS
    output led_strip
  ) {
  
  sig rst;                  // reset signal

  // Checker signals; use ALU and check against one value
  sig checkEqualsZero; 
  sig checkOtherStack;
  sig checkLessThanTwo;
  sig checkLessThanOne;
  sig checkLeftStackZero;
  sig checkMiddleStackZero;
  sig checkRightStackZero;
  
  // Initialise ALUs
  alu alu16;

  const ADD = 6b000000;
  const SUB = 6b000001;
  const AND = 6b011000;
  const OR  = 6b011110;
  const XOR = 6b010110;
  const AONLY = 6b011010;
  const SHL = 6b100000;
  const SHR = 6b100001;
  const SRA = 6b100011;
  const CMPEQ = 6b110011;
  const CMPLE = 6b110101;
  const CMPLT = 6b110111;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;

    // Button Detector circuits below:
    // EDGE DETECTORS (find falling edges to mark an input)
    edge_detector detectMoveLP1(#RISE(0), #FALL(1));
    edge_detector detectMoveRP1(#RISE(0), #FALL(1));
    edge_detector detectUpRm1P1(#RISE(0), #FALL(1));
    edge_detector detectDnRm2P1(#RISE(0), #FALL(1));
    edge_detector detectMoveLP2(#RISE(0), #FALL(1));
    edge_detector detectMoveRP2(#RISE(0), #FALL(1));
    edge_detector detectUpRm1P2(#RISE(0), #FALL(1));
    edge_detector detectDnRm2P2(#RISE(0), #FALL(1));
    edge_detector detectReset(#RISE(0), #FALL(1));
    edge_detector detectStart(#RISE(0), #FALL(1));

    // BUTTON CONDITIONERS: Ensure clean input from buttons
    button_conditioner buttonMoveLP1;
    button_conditioner buttonMoveRP1;
    button_conditioner buttonRemove1P1;
    button_conditioner buttonRemove2P1;
    
    button_conditioner buttonMoveLP2;
    button_conditioner buttonMoveRP2;
    button_conditioner buttonRemove1P2;
    button_conditioner buttonRemove2P2;
    
    button_conditioner buttonStart;
    button_conditioner buttonReset;
    
    .rst(rst){
      lfsr_rand randl;
      lfsr_rand randm;
      lfsr_rand randr;
      dff leftstack[10](#INIT(10b1111111111)); // set left stack to 10
      dff middlestack[10](#INIT(10b1111111111)); // set middle stack to 10
      dff rightstack[10](#INIT(10b1111111111)); // set right stack to 10
            
      dff turn_blink[4][4](#INIT({4d0,4d0,4d0,4d0})); // blink to indicate player turn
      dff location_blink[8](#INIT(8b0)); // blink to indicate player location_blink
      
      multi_seven_seg seg;
      dff playerscores[4][4](#INIT({4d0,4d0,4d0,4d0}));  // left two scores for Player 1, right two scores for Player 2
    }
  }
  fsm states(.clk(clk), .rst(rst)) = {START, P1L, P1M, P1R, P1C, P2L, P2M, P2R, P2C};
  // states
  // P1L: player 1 left stack
  // P1M: player 1 middle stack
  // P1R: player 1 right stack
  // P1C: end of player 1's turn, in here we check if player 1 wins
  // P2L: player 2 left stack
  // P2M: player 2 middle stack
  // P2R: player 2 right stack
  // P2C: end of player 2's turn, in here we check if player 2 wins
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 3x{{10b0}};
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    // NOTE TO EDIT: ALL STACKS COME FROM SAME DATALINE
    led[2] = leftstack.q;   // left stack LEDs
    led[1] = middlestack.q; // middle stack LEDs
    led[0] = rightstack.q;  // right stack LEDs
    
    io_seg = ~seg.seg; // connect segments to the driver
    io_sel = ~seg.sel; // connect digits to the driver
    seg.values = playerscores.q; // initialise player scores
    
    // initialise inputs/outputs as 0 first, then change input accordingly later
    alu16.a = 16b0;
    alu16.b = 16b0;
    alu16.opcode = 6b0;
    
    led_strip = 1b0;
    
    // Button Initializing
    buttonStart.in = io_startgame;
    detectStart.in = buttonStart.out;
    
    buttonReset.in = io_reset;
    detectReset.in = buttonReset.out;

    buttonMoveLP1.in = io_button[0][3];
    buttonMoveRP1.in = io_button[0][4];
    buttonRemove1P1.in = io_button[0][0];
    buttonRemove2P1.in = io_button[0][2];

    buttonMoveLP2.in = io_button[1][3];
    buttonMoveRP2.in = io_button[1][4];
    buttonRemove1P2.in = io_button[1][0];
    buttonRemove2P2.in = io_button[1][2];

    detectMoveLP1.in = buttonMoveLP1.out;
    detectMoveRP1.in = buttonMoveRP1.out;
    detectUpRm1P1.in = buttonRemove1P1.out;
    detectDnRm2P1.in = buttonRemove2P1.out;

    detectMoveLP2.in = buttonMoveLP2.out;
    detectMoveRP2.in = buttonMoveRP2.out;
    detectUpRm1P2.in = buttonRemove1P2.out;
    detectDnRm2P2.in = buttonRemove2P2.out;

    
    // Commented out as we're using external IOs now
    /*
    buttonleft.in = io_button[3];
    detectMoveLP1.in = buttonleft.out;
    buttonright.in = io_button[4];
    detectMoveRP1.in = buttonright.out;
    buttonupremove1.in = io_button[0][0];
    detectUpRm1P1.in = buttonupremove1.out;
    buttondownremove2.in = io_button[2];
    detectDnRm2P1.in = buttondownremove2.out;
    buttonstartgame.in = io_startgame;
    detectstart.in = buttonstartgame.out;
    buttonreset.in = io_reset;
    detectReset.in = buttonreset.out;*/

    // Activate randomisers
    randl.enable = 1;
    randm.enable = 1;
    randr.enable = 1;
    

    case(states.q){
      states.START:
        /*led[2] = randl.out; // no blinking to indicate location
        led[1] = randm.out; // no blinking to indicate location
        led[0] = randr.out; // no blinking to indicate location*/
        
        randl.enable = 1;  // to re-randomise if player resets game
        randm.enable = 1;
        randr.enable = 1;
        
        seg.values = playerscores.q;
        leftstack.d   = randl.out;
        middlestack.d = randm.out;
        rightstack.d  = randr.out;
        if (detectStart.out == 1){
          states.d = states.P1M;
        } else {
          states.d = states.START;
        }
        
      states.P1M:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        /*

        if (turn_blink.q == playerscores.q){
          turn_blink.d[1:0] = playerscores.q[1:0];
          turn_blink.d[3:2] = {4b0,4b0};
        } else {
          turn_blink.d = playerscores.q;
        }
        led[2] = leftstack.q;   // no blinking to indicate location
        led[1] = location_blink.q; // BLINKING to indicate location
        led[0] = rightstack.q;  // no blinking to indicate location        
        */
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if(detectMoveLP1.out == 1){
          alu16.a = leftstack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P1M;
          } else {
            states.d = states.P1L;
          }
        }
        else if (detectMoveRP1.out == 1){
          alu16.a = rightstack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P1M;
          } else {
            states.d = states.P1R;
          }
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = middlestack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P1M;
          }else{
            alu16.opcode = SHR;
            middlestack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = middlestack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 2
            states.d = states.P1M;
          }else{
            alu16.opcode = SHR;
            middlestack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }

      states.P1L:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if (detectMoveLP1.out == 1){
          states.d = states.P1L;
        }
        else if (detectMoveRP1.out == 1) {
          alu16.a = middlestack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P1R;
            
            alu16.a = rightstack.q;
            checkOtherStack = alu16.out[0];
            if (checkOtherStack == 1){
              states.d = states.P1L;
            }
          } else {
            states.d = states.P1M;
          }
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = leftstack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P1L;
          }else{
            alu16.opcode = SHR;
            leftstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = leftstack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P1L;
          }else{
            alu16.opcode = SHR;
            leftstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }
        
        /*
        seg.values = turn_blink.q;
           
        if (turn_blink.q == playerscores.q){
          turn_blink.d[1:0] = playerscores.q[1:0];
          turn_blink.d[3:2] = {4b0,4b0};
        }else{
          turn_blink.d = playerscores.q;
        }   
        
        led[2] = location_blink.q; // BLINKING to indicate location
        led[1] = middlestack.q; // no blinking to indicate location
        led[0] = rightstack.q; // no blinking to indicate location    
        
        if (location_blink.q == leftstack.q){
          location_blink.d = 8b0;
        }else{
          location_blink.d = leftstack.q;  // CHECK WITH SAMSON WHAT DOES THAT MEAN
        } 
        */
        
      states.P1R:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if (detectMoveLP1.out == 1){
          alu16.a = middlestack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P1L;
            
            alu16.a = leftstack.q;
            checkOtherStack = alu16.out[0];
            if (checkOtherStack == 1){
              states.d = states.P1R;
            }
          } else {
            states.d = states.P1M;
          }
        }
        else if (detectMoveRP1.out == 1) {
          states.d = states.P1R;
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = rightstack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P1R;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = rightstack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P1R;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P1C;
          }
        }
        
      states.P2M:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if (detectMoveLP1.out == 1){
          alu16.a = leftstack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P2M;
          }else{
            states.d = states.P2L;
          }
        }
        else if (detectMoveRP1.out == 1) {
          alu16.a = rightstack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P2M;
          }else{
            states.d = states.P2R;
          }
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = middlestack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2M;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = middlestack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2M;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        
      states.P2L:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if (detectMoveLP1.out == 1){
          states.d = states.P2L;
        }
        else if (detectMoveRP1.out == 1) {
          alu16.a = middlestack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P2R;
            
            alu16.a = rightstack.q;
            checkOtherStack = alu16.out[0];
            if (checkOtherStack == 1){
              states.d = states.P2L;
            }
          } else {
            states.d = states.P2M;
          }
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = leftstack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2L;
          }else{
            alu16.opcode = SHR;
            leftstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = leftstack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2L;
          }else{
            alu16.opcode = SHR;
            leftstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        
      states.P2R:
        seg.values = playerscores.q;
        
        randl.enable = 0;
        randm.enable = 0;
        randr.enable = 0;
        
        if (detectReset.out == 1){
          states.d = states.START;
        }
        
        alu16.b = 16b1;
        alu16.opcode = CMPLT;
        
        if (detectMoveLP1.out == 1){
          alu16.a = middlestack.q;
          checkEqualsZero = alu16.out[0];
          if (checkEqualsZero == 1){
            states.d = states.P2L;
            
            alu16.a = leftstack.q;
            checkOtherStack = alu16.out[0];
            if (checkOtherStack == 1){
              states.d = states.P2R;
            }
          } else {
            states.d = states.P2M;
          }
        }
        else if (detectMoveRP1.out == 1) {
          states.d = states.P2R;
        }
        else if (detectUpRm1P1.out == 1){
          alu16.a = rightstack.q;
          alu16.b = 16b1;
          alu16.opcode = CMPLT;
          checkLessThanOne = alu16.out;
          
          if (checkLessThanOne == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2R;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        else if (detectDnRm2P1.out == 1){
          alu16.a = rightstack.q;
          alu16.b = 16b10;
          alu16.opcode = CMPLT;
          checkLessThanTwo = alu16.out;
          
          if (checkLessThanTwo == 16b1){  // Check if there is enough LEDs left to shift right by 1
            states.d = states.P2R;
          }else{
            alu16.opcode = SHR;
            rightstack.d = alu16.out;  // input of alu16 is alr at most 10 digits, so dropping most sig bit is ok
            states.d = states.P2C;
          }
        }
        
      states.P1C:
        alu16.a = leftstack.q;
        alu16.b = 8b0;
        alu16.opcode = CMPEQ;
        
        if (alu16.out && middlestack.q == 16b0 && rightstack.q == 16b0){    // If all stacks are empty, restart game
          if (playerscores.q[2] == 4d9){
            playerscores.d[2] = 4d0;
            playerscores.d[3] = playerscores.q[3] + 4d1;
          }else{
            playerscores.d[2] = playerscores.q[2] + 4d1;
          }
          states.d = states.START;
        }else{
          alu16.a = leftstack.q;
          alu16.b = 8b1;
          alu16.opcode = CMPLT;
                    
          if (middlestack.q >= 8b1){
            states.d = states.P2M;
          }else if (!alu16.out){
            states.d = states.P2L;
          }else{
            states.d = states.P2R;
          }
        }
          
      states.P2C:
        alu16.a = leftstack.q;
        alu16.b = 8b0;
        alu16.opcode = CMPEQ;
        
        if (alu16.out && middlestack.q == 16b0 && rightstack.q == 16b0){    // If all stacks are empty, restart game
          if (playerscores.q[0] == 4d9){
            playerscores.d[0] = 0;
            playerscores.d[1] = playerscores.q[1] + 4d1;
          }else{
            playerscores.d[0] = playerscores.q[0] + 4d1;
          }
          states.d = states.START;
        }else{
          alu16.a = leftstack.q;
          alu16.b = 8b1;
          alu16.opcode = CMPLT;
        
          if (middlestack.q >= 16b0){
            states.d = states.P2M;
          }else if (!alu16.out){
            states.d = states.P2L;
          }else{
            states.d = states.P2R;
          }
        }
        
      default:
        states.d = states.P1M;
          
  }
  }
}